[{"categories":["emacs"],"content":"Memo 主题下的配置 现在的 Blog 主题基于 Hugo 主题 MemE 文档 | reuixiy 来做的，看了下文档，天然的原生支持 Mermaid , 就不用针对 hugo 做太多定制化的东西，需要注意 导出的配置的 Front Matter 有 mermaid true 的配置即可\n我们用的是 ox-hugo ， 我们需要在自定义 FRONT_MATTER\n1 :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :mermaid true 其次在 org-bable 中，对 mermaid 进行如下配置\n1 2 3 4 5 6 #+begin_src mermaid :exports code :results raw :hugo-shortcode mermaid graph TD; A--\u003eB; A--\u003eC; B--\u003eD; C--\u003eD; 示例 如上的配置，就能正常转为 mermaid 图\ngraph TD; A--\u003eB; A--\u003eC; B--\u003eD; C--\u003eD; ","description":"","tags":["hugo"],"title":"ox-hugo 集成 mermaid","uri":"/posts/ox-hugo-%E9%9B%86%E6%88%90-mermaid/"},{"categories":["Reading"],"content":"书名：《Kafka权威指南（第2版）》\n作者：格温·沙皮拉 托德·帕利诺 拉吉尼·西瓦拉姆 克里特·佩蒂\n评分： 🌟🌟🌟\n简评 O’Reilly 家的技术书，总体风格都差不多，属于偏入门向的书籍，这本书也一样，能给我们一个基本的框架结构，对 Kafka 有一个基本程度的了解,并对其设计与优化思路有一个大体的掌控\n重点看了 1 - 7 章 ，8 ，9 章主要面向 Stream , 10 - 13 章 偏 OP 一些，后边有需求在回头看看\nKafka 设计之初可能是一个分布式的消息队列，但是随着其不断的迭代更新，现在称其为一个 分布式日志系统更合适一些。\n首先，分布式系统能遇到的问题,Kafka 也会遇到，分布式系统的本质是一种基于不同场景的取舍， Kafka 的设计思路，是把这些取舍，交还给了用户，这也就是 Kafka 为什么难的原因\n把选择权交给用户，这会提高系统设计的复杂难度，相对的，用户使用起来也会相对的困难，需要了解相关的知识也更多，但是这可能恰恰是 Kafka 如此流行的原因，因为其适应性广，这就让 Kafka 走出了一条与其他消息队列不同的路\n本书没有特别深入到很底层的实现，而是从设置，使用层面，来简单的介绍了我们使用 Kafaka 中，在不同场景下，需要进行的一些配置，需要做的一些实现以及一些比较好的实践方式。\n所以如果对特别底层感兴趣的话，这本书并不适合，市面上也没有找到特别符合的书，可能之间看源码更合适一些\nDEMO graph TD; A--\u003eB; A--\u003eC; B--\u003eD; C--\u003eD; ","description":"","tags":null,"title":"《Kafka权威指南（第2版）》 简评","uri":"/posts/kafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC2%E7%89%88-%E7%AE%80%E8%AF%84/"},{"categories":["Algorithm"],"content":"题目信息 题目难度: Easy 掌握程度: 🌟🌟🌟🌟🌟\n1299. 将每个元素替换为右侧最大元素 - 力扣（LeetCode）\n解题思路 解法 1 ： 模拟 遍历位置，从当前位置获取当前位置右边最大值，替换当前值即可\n时间复杂度 \\(O(n^2)\\)\n1 2 3 4 5 6 7 8 9 10 11 public int[] replaceElements(int[] arr) { for(int i = 0 ; i \u003c arr.length - 1 ; i++){ int max = arr[i+1]; for(int j = i + 1; j \u003c arr.length;j++){ max = Math.max(arr[j],max); } arr[i] = max; } arr[arr.length - 1] = -1; return arr; } 解法 2： 一次遍历 反向遍历，从数组右边开始遍历，此时我们通过维护一个 pre 变量来标识当前元素右侧最大元素值，进行替换\n替换之后，如果当前元素 cur \u003e pre ，那么我们就替换 pre 为当前元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public int[] replaceElements(int[] arr) { int n = arr.length; int pre = arr[n-1]; for(int i = n - 1 ; i \u003e= 0 ; i--){ int tmp = arr[i]; if(i == n-1){ arr[i] = -1; }else{ arr[i] = pre; } if(tmp \u003e pre){ pre = tmp; } } return arr; } ","description":"","tags":["alg@arr"],"title":"每日一题20250216-LC1299","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9820250216-lc1299/"},{"categories":["Algorithm"],"content":"题目信息 题目难度： Medium 掌握程度： 🌟🌟\n1706. 球会落何处 - 力扣（LeetCode）\n用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。\n箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。\n将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。 将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。 在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 “V” 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。\n返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。\n示例 1：\n输入：grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]] 输出：[1,-1,-1,-1,-1] 解释：示例如图： b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。 b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 “V” 形里。 b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 “V” 形里。 b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 “V” 形里。 b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 “V” 形里。 示例 2：\n输入：grid = [\\[-1\\]] 输出：[\\-1\\] 解释：球被卡在箱子左侧边上。 示例 3：\n输入：grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]] 输出：[0,1,2,3,4,-1]\n解题思路 小球从 第一层进入，\n如果是 1 ，则先向右移动，如果没有遇到边界，则向下移动\n如果是 -1 ， 则先向做移动，如果没有遇到编辑，则向下移动\n关于边界的定义，就是 物理边界以及 V 型都是边界情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public int[] findBall(int[][] grid) { int n = grid[0].length; int[] result = new int[n]; for(int j = 0 ; j \u003c n ; j++){ int curCol = j; for(int[] row : grid){ int direction = row[curCol]; curCol += direction; if(curCol \u003c 0 || curCol \u003e= n || row[curCol] != direction){ curCol = -1; break; } } result[j] = curCol; } return result; } ","description":"","tags":["alg@simulation"],"title":"每日一题20250215-LC1706","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9820250215-lc1706/"},{"categories":["Algorithm"],"content":"题目信息 题目难度：Medium 掌握程度：🌟🌟🌟\n1552. 两球之间的磁力 - 力扣（LeetCode）\n在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。\n已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。\n给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。\n示例 1：\n输入：position = [1,2,3,4,7], m = 3 输出：3 解释：将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。我们没办法让最小磁力大于 3 。\n示例 2：\n输入：position = [5,4,3,2,1,1000000000], m = 2 输出：999999999 解释：我们使用位于 1 和 1000000000 的篮子时最小磁力最大。\n提示：\nn = position.length 2 \u003c n \u003c= 10^5 1 \u003c= position[i] \u003c= 10^9 所有 position 中的整数 互不相同 。 2 \u003c= m \u003c= position.length\n解题思路 本题与 LC1760 类似，都是利用二分的思路来处理\n具体思路如下：\n我们可以「猜测」一个候选的最小距离 d ，然后验证是否存在一种放置方案，使得所有相邻球之间的距离均 ≥ d。 这个验证过程就是一个决策问题，其答案只有“可行”或“不行”。 然后我们对整个解空间进行二分，快速找到满足要求的 d 。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public int maxDistance(int[] position, int m) { Arrays.sort(position); int l = 1 ; int r = position[position.length-1] - position[0]; int ans = -1; while(l \u003c= r){ int mid = (l + r) / 2; if(check(mid,position,m)){ ans = mid; l = mid + 1; }else{ r = mid - 1; } } return ans; } private boolean check(int x , int[]position,int m){ int cnt = 1; int pre = position[0]; for(int i = 1 ; i \u003c position.length; i++){ if(position[i] - pre \u003e= x ){ pre = position[i]; cnt++; } } return cnt \u003e= m; } } 扩展 对于 最大最小化问题 或者 最小最大化问题 ，我们都可以利用 二分搜索来优化解题速度\n这种问题都可以转化为 决策问题 ，我们可以「猜测」一个候选值，然后判断是否存在一个方案，使得所有条件都能满足这一要求。\n对于我们猜测的候选值，他在解空间内是具有单调性的，比如对于候选值 X，如果“最小值至少为 X”这一条件可行，那么对于所有比 X 小的候选值通常也是可行的（或者在某些问题中恰好相反：如果 X 不可行，则所有比 X 大的候选值也不可行）。所以可以用 BinarySearch 而我们，二分搜索的收敛范围，是针对整个解空间的，而不是像普通的二分，是针对输入的数组\n","description":"","tags":["alg@binarySearch"],"title":"每日一题20250214-LC1552","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9820250214-lc1552/"},{"categories":["Algorithm"],"content":"题目信息 题目难度：Easy 掌握程度：🌟🌟🌟\n1742. 盒子中小球的最大数量 - 力扣（LeetCode）\n你在一家生产小球的玩具厂工作，有 n 个小球，编号从 lowLimit 开始，到 highLimit 结束（包括 lowLimit 和 highLimit ，即 n == highLimit - lowLimit + 1）。另有无限数量的盒子，编号从 1 到 infinity 。\n你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号 321 的小球应当放入编号 3 + 2 + 1 = 6 的盒子，而编号 10 的小球应当放入编号 1 + 0 = 1 的盒子。\n给你两个整数 lowLimit 和 highLimit ，返回放有最多小球的盒子中的小球数量。如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。\n示例 1：\n输入：lowLimit = 1, highLimit = 10 输出：2 解释： 盒子编号：1 2 3 4 5 6 7 8 9 10 11 … 小球数量：2 1 1 1 1 1 1 1 1 0 0 … 编号 1 的盒子放有最多小球，小球数量为 2 。 示例 2：\n输入：lowLimit = 5, highLimit = 15 输出：2 解释： 盒子编号：1 2 3 4 5 6 7 8 9 10 11 … 小球数量：1 1 1 1 2 2 1 1 1 0 0 … 编号 5 和 6 的盒子放有最多小球，每个盒子中的小球数量都是 2 。 示例 3：\n输入：lowLimit = 19, highLimit = 28 输出：2 解释： 盒子编号：1 2 3 4 5 6 7 8 9 10 11 12 … 小球数量：0 1 1 1 1 1 1 1 1 2 0 0 … 编号 10 的盒子放有最多小球，小球数量为 2 。\n提示：\n1 \u003c= lowLimit \u003c= highLimit \u003c= 105\n解题思路 计算 lowLimit 到 highLimit 每个数会落入的盒子，统计计数即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public int countBalls(int lowLimit, int highLimit) { Map\u003cInteger,Integer\u003e map = new HashMap\u003c\u003e(); Integer maxCnt = 0; for(int i = lowLimit ; i \u003c= highLimit ; i++){ int box = calc(i); int cnt = map.getOrDefault(box,0); map.put(box,++cnt); maxCnt = Math.max(maxCnt,cnt); } return maxCnt; } private int calc(int x){ int res = 0 ; while(x\u003e0){ res += x %10; x /= 10; } return res; } 小优化 highLimit\u003c=10^5 ，盒子的大小不会超过 46 ，可以用数组替代 Map\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public int countBalls(int lowLimit, int highLimit) { int[] map = new int[46]; Integer maxCnt = 0; for(int i = lowLimit ; i \u003c= highLimit ; i++){ int box = calc(i); map[box]++; maxCnt = Math.max(maxCnt,map[box]); } return maxCnt; } private int calc(int x){ int res = 0 ; while(x\u003e0){ res += x %10; x /= 10; } return res; } ","description":"","tags":["alg@hash"],"title":"每日一题20250213-LC1742","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9820250213-lc1742/"},{"categories":["Algorithm"],"content":"题目信息 题目难度： Medium 掌握程度： 🌟🌟\n1760. 袋子里最少数目的球 - 力扣（LeetCode）\n给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。\n你可以进行如下操作至多 maxOperations 次：\n选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。 比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。 你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。\n请你返回进行上述操作后的最小开销。\n示例 1：\n输入：nums = [9], maxOperations = 2 输出：3 解释：\n将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -\u003e [6,3] 。 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -\u003e [3,3,3] 。 装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。 示例 2：\n输入：nums = [2,4,8,2], maxOperations = 4 输出：2 解释：\n将装有 8 个球的袋子分成装有 4 个和 4 个球的袋子。[2,4,8,2] -\u003e [2,4,4,4,2] 。 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,4,4,4,2] -\u003e [2,2,2,4,4,2] 。 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,4,4,2] -\u003e [2,2,2,2,2,4,2] 。 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,2,2,4,2] -\u003e [2,2,2,2,2,2,2,2] 。 装有最多球的袋子里装有 2 个球，所以开销为 2 并返回 2 。 示例 3：\n输入：nums = [7,17], maxOperations = 2 输出：7\n提示：\n1 \u003c= nums.length \u003c= 105 1 \u003c= maxOperations, nums[i] \u003c= 109\n解题思路 通过提示我们可以把问题转换成，如果知道包裹元素的最大值，那么我们如何知道最小的包裹数量\n我们假设包裹元素最多是 m 个，最小的包裹数量为 k , 我们需要计算的是 把 m 个包裹元素分成 k 包裹的操作次数 n 能否满足 n\u003c=maxOperations\n我们可以确定包裹的最大元素是 MAX(nums) , 最小是 1 , 这个区间是满足单调性的，所以可以使用二分搜索，我们通过二分搜索找到最满足条件的 m [1,MAX(nums)] 即为结果\n对于包裹里的每个元素 nums[i] 来说，我们计算他需要分成 m 个的操作次数为 \\(n=[nums[i]-1/m]\\)\n当 n\u003c=maxOperations 是，说明满足条件，我们缩短右边界 反之，我们缩短左边界 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int minimumSize(int[] nums, int maxOperations) { int mx = 0; for (int x : nums) { mx = Math.max(mx, x); } int left = 0; // 循环不变量 check(left) == false int right = mx; // 循环不变量 check(right) == true while (left + 1 \u003c right) { int mid = (left + right) \u003e\u003e\u003e 1; if (check(nums, maxOperations, mid)) { right = mid; } else { left = mid; } } return right; } private boolean check(int[] nums, int maxOperations, int m) { long cnt = 0; for (int x : nums) { cnt += (x - 1) / m; } return cnt \u003c= maxOperations; } } ","description":"","tags":["alg@binarySearch"],"title":"每日一题20250212-LC1760","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9820250212-lc1760/"},{"categories":["Algorithm"],"content":"题目信息 题目难度：medium 掌握程度：🌟🌟🌟\n80. 删除有序数组中的重复项 II - 力扣（LeetCode）\n给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n说明：\n为什么返回数值是整数，但输出的答案是数组呢？\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums);\n/ 在函数里修改输入数组对于调用者是可见的。 / 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u003c len; i++) { print(nums[i]); }\n示例 1：\n输入：nums = [1,1,1,2,2,3] 输出：5, nums = [1,1,2,2,3] 解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。 示例 2：\n输入：nums = [0,0,1,1,1,1,2,3,3] 输出：7, nums = [0,0,1,1,2,3,3] 解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。\n提示：\n1 \u003c= nums.length \u003c= 3 * 104 -104 \u003c= nums[i] \u003c= 104 nums 已按升序排列\n解题思路 相对 26. 删除有序数组中的重复项 - 力扣（LeetCode） 来说困难点在没个元素最多出现两次,思路基本一致，通过双指针来进行一 次遍历，遍历过程中对元素进行 swap 操作，来满足时间和空间复杂度的要求\n首先我们维护两个指针 slow , fast , 当重复元素超过 2 个时，我们交换 fast slow 所在的元素， 直到 fast 迭代到 nums 的尾部时结束循环，现在看看如何处理重复元素这一个问题如果我们在去考虑维护一个计数器来记录次数，但是换种思路来看，数组是有序的，如果是 [1,1,1,2,2,3] 这个 case ，我们只需要判断 nums[slow-2] 是否与当前元素一致即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int removeDuplicates(int[] nums) { if(nums.length \u003c 2){ return nums.length; } int slow = 2; int fast = 2; while(fast \u003c nums.length){ if(nums[slow-2] != nums[fast]){ swap(nums,slow,fast); slow++; } fast++; } return slow; } private void swap(int[] nums,int x ,int y){ int tmp = nums[x]; nums[x] = nums[y]; nums[y] = tmp; } } ","description":"","tags":null,"title":"每日一题20250209-LC80","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9820250209-lc80/"},{"categories":["Algorithm"],"content":"题目信息 题目难度：中等 掌握程度: 🌟🌟🌟🌟🌟\n63. 不同路径 II - 力扣（LeetCode）\n解题思路 二维 DP 的基础题目，由于只能从左边或者上边移动到当前单元格 所以当前 \\(格子的路径数量=上方路径数量+左方路径数量\\)\nBaseCase\n首行首列的情况下，只有一条路径，所以全部初始化为 1 即可，需要注意的是，由于加入了障碍物，所以，首行首列的障碍物，会导致后面的格子没法到达，所有遇到障碍物以后，就直接跳出循环\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for(int i = 0 ; i \u003c m ; i++){ if(obstacleGrid[i][0] == 0){ dp[i][0] = 1; }else{ break; } } for(int i = 0 ; i \u003c n; i++){ if(obstacleGrid[0][i] == 0){ dp[0][i] = 1; }else{ break; } } for(int i = 1 ; i \u003c m; i++){ for(int j = 1 ; j \u003c n ;j++){ if(obstacleGrid[i][j] == 1){ dp[i][j] = 0; }else{ dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } } return dp[m-1][n-1]; } } ","description":"","tags":["alg@dp"],"title":"每日一题20250208-LC63","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9820250208-lc63/"},{"categories":["Algorithm"],"content":"题目信息 题目难度：中等 掌握程度：🌟🌟🌟🌟\n59. 螺旋矩阵 II - 力扣（LeetCode）\n给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n示例 1：\n1 2 3 8 9 4 7 6 5 输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2：\n输入：n = 1 输出：\\[[1]\\]\n提示：\n1 \u003c= n \u003c= 20\n解题思路 模拟，舍得用变量，用 4 个变量分别控制 上、下、左、右 四个边界\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public int[][] generateMatrix(int n) { int[][] res = new int[n][n]; int num = 1; // 确定边界范围 int top = 0 , bottom = n-1; int left = 0 , right = n-1; while(num \u003c= n*n){ //top left -\u003e top right for(int i = left ; i \u003c= right ; i++){ res[top][i] = num++; } top++; //top right -\u003e bottom right for(int i = top ; i \u003c= bottom ; i++){ res[i][right] = num++; } right--; //bottom right -\u003e bottom left for(int i = right ; i \u003e= left ;i --){ res[bottom][i] = num++; } bottom--; //bottom left -\u003e top left for(int i = bottom ; i \u003e= top; i--){ res[i][left] = num++; } left++; } return res; } } ","description":"","tags":["alg@simulation"],"title":"每日一题20250207-LC59","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9820250207-lc59/"},{"categories":["Algorithm"],"content":"题目信息 题目难度：medium 掌握程度：🌟🌟🌟\n47. 全排列 II - 力扣（LeetCode）\n给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。\n示例 1：\n输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]] 示例 2：\n输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n提示：\n1 \u003c= nums.length \u003c= 8 -10 \u003c= nums[i] \u003c= 10\n解题思路 回溯，在全排列的基础上加了两个扩展，\n输入数字有重复 结果需要不重复 需要想办法去重，有两个策略，直接暴力回溯，然后对结果直接进行一次去重即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { private Set\u003cList\u003cInteger\u003e\u003e res; private List\u003cInteger\u003e path; private boolean[] visited; public List\u003cList\u003cInteger\u003e\u003e permuteUnique(int[] nums) { res = new HashSet\u003c\u003e(); path = new ArrayList\u003c\u003e(); visited = new boolean[nums.length]; backtrack(nums,nums.length); return new ArrayList\u003c\u003e(res); } private void backtrack(int[] nums,int n){ if(path.size() == n){ res.add(new ArrayList\u003c\u003e(path)); return; } for(int i = 0 ; i \u003c n ; i++){ if(!visited[i]){ path.add(nums[i]); visited[i] = true; backtrack(nums,n); visited[i] = false; path.remove(path.size()-1); } } } } 优化 在不用 set 的情况下，如何去重\n先看看是如何重复的 比如 [1,1,2], 重复的话，就会出现两个 [1,1,2]\n考虑重复元素一定要 优先排序 ，将重复的都放在一起，便于找到重复元素和剪枝！！！\n当前元素和前一个元素值相同（此处隐含这个元素的 index\u003e0 ），并且前一个元素还没有被使用过的时候，我们要剪枝\n即\n1 2 3 if(visited[i] || (i \u003e 0 \u0026\u0026 nums[i] == nums[i - 1] \u0026\u0026 !visited[i - 1]) ){ continue; } 最后答案\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { private List\u003cList\u003cInteger\u003e\u003e res; private List\u003cInteger\u003e path; private boolean[] visited; public List\u003cList\u003cInteger\u003e\u003e permuteUnique(int[] nums) { res = new ArrayList\u003c\u003e(); path = new ArrayList\u003c\u003e(); visited = new boolean[nums.length]; Arrays.sort(nums); backtrack(nums,nums.length); return res; } private void backtrack(int[] nums,int n){ if(path.size() == n){ res.add(new ArrayList\u003c\u003e(path)); return; } for(int i = 0 ; i \u003c n ; i++){ if(visited[i] || (i \u003e 0 \u0026\u0026 nums[i] == nums[i - 1] \u0026\u0026 !visited[i - 1]) ){ continue; } path.add(nums[i]); visited[i] = true; backtrack(nums,n); visited[i] = false; path.remove(path.size()-1); } } } 相关题目 回溯排列的基础题目\n46. 全排列 - 力扣（LeetCode）\n回溯组合的基础题目 77. 组合 - 力扣（LeetCode）\n排列与组合的主要差异在于\n排列需要维护一个 visited[] 数组来标记当前元素是否已选择，组合需要在回溯过程中，控制选择区间\n","description":"","tags":["alg@backtrack"],"title":"每日一题20250206-LC47","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9820250206-lc47/"},{"categories":["Life"],"content":"2024 一年过去了，简单的做个总结，记录一下 25 年的规划吧\n24 年目标完成 考取无线电执照 晋升 英语学习 阅读 博客搭建 24 年概况 旅游 4 月初去了一趟新西兰，总体感觉确实不错，人少，小国家，环境很好，冒险者的天堂，在 Tekapo 确实拍到了几张很不错的的银河照片，也第一次体验到了巴雷特的威力，确实很爽，要说遗憾的话，就是天气原因导致没能飞库克山。总体来说，14 天的行程如果南北岛都逛的话，相对有一些紧张，后面几天，多数时间就是在赶路了，可以的话南岛还是从皇后镇直接飞奥克兰跟宽松一些。整体体验确实不错，有机会可以尝试去转一下。\n10 月份回家，就带媳妇顺道去了趟中卫，感觉比很多年前要好上不少，体验了一晚星星酒店，跟沙疗，遗憾的话，确实没时间去玩做黄河滑索。\n12 月离职了，走了广州-佛山-珠海-澳门-深圳，吃吃吃，要说感受，可能澳门给我的感触是最大的，赌场的洗手间、吸烟室、你能看到形形色色的人，有些人，真的就像附骨之蛆，闻着味就来了，不但不拉人一把，还会在推你离深渊更近一些，但是这都是个人的选择，确实很难评价。\n学习 无线电没考上，一直没有约到，很遗憾，本来打算考了证，给车上装部电台玩玩，一直就没约到，最近几个月，之前的题目都忘得差不多了，估计得重新来过\n英语,去年单词打卡了 187 天，不算太好，继续努力吧\n阅读，去年读了 39 本书，读完的就只有 8 本，由于入坑摄影， 认真的读完了 《新摄影笔记》，算是一本不错的入门书，至少能明确理解摄影三要素； 还有1本乱步的推理小说集； 《仙症》是看完了葛大爷的电影，回去找来读的，逼疯一个人的到底是什么？时代还是偏见； 《平面国》很难想到这是一本 100 多年前的书，阻挡我们认清现实的到底是维度还是阶级？ 《软技能》，看了这本书，才决定把我的播客给搭起来； 《月亮与六便士》，媳妇特别喜欢这本书，就看了下，不疯魔不成活，就是我对主人公的评价； 《每天都想陪伴你》很治愈的小漫画。\n《SICP》这部大部头,确实难啃，看看今年能不能啃下来吧 《DDIA》确实不错，但是兜兜转转的，也没完全看完，不过里面介绍的一些思想，确实很底层或者常用，比如 WAL ，这个在主流 DB 里，基本都有相应的变体来实现。Redis 的 AOF ， InnoDB 的 redo log ， mongo 的 jounal 其实都是 WAL 变体。\n工作 其实整体工作都做的不错，本来还想 9 月份能晋升，结果没提名， 11 月，跟公司 match 一下，离职了。\n其他 笔记软件折腾来折腾去，最后转到了 emacs ，emacs 这个古董确实有些东西，播客也转到 emacs 上，结合 hugo ，搭建起来了\n年底买了个 breville 的咖啡机，看看能不能少喝点星巴克\n25 年计划 找工作 英语学习坚持打卡 300 天 阅读 LC 随缘打卡，但是不低于 100 天 看完 《DDIA》 啃完 《SICP》 咖啡能拉一个不错的拉花 考无线电执照 英语转到了多邻国，体感比单纯的背单词要好不少，看看能不能坚持一整年不\n短期内的目标还是找工作，期间的话，可能会刷刷题，维持一下博客的更新，多读读基础上类的书籍，补充一下短板\n基本上就这些了希望 25 年能顺顺利利吧\n","description":"","tags":null,"title":"年终总结","uri":"/posts/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["Algorithm"],"content":"题目信息 掌握程度: 🌟\n2944. 购买水果需要的最少金币数 - 力扣（LeetCode）\n给你一个 下标从 1 开始的 整数数组 prices ，其中 prices[i] 表示你购买第 i 个水果需要花费的金币数目。\n水果超市有如下促销活动：\n如果你花费 prices[i] 购买了下标为 i 的水果，那么你可以免费获得下标范围在 [i + 1, i + i] 的水果。 注意 ，即使你 可以 免费获得水果 j ，你仍然可以花费 prices[j] 个金币去购买它以获得它的奖励。\n请你返回获得所有水果所需要的 最少 金币数。\n示例 1：\n输入：prices = [3,1,2]\n输出：4\n解释：\n用 prices[0] = 3 个金币购买第 1 个水果，你可以免费获得第 2 个水果。 用 prices[1] = 1 个金币购买第 2 个水果，你可以免费获得第 3 个水果。 免费获得第 3 个水果。 请注意，即使您可以免费获得第 2 个水果作为购买第 1 个水果的奖励，但您购买它是为了获得其奖励，这是更优化的。\n示例 2：\n输入：prices = [1,10,1,1]\n输出：2\n解释：\n用 prices[0] = 1 个金币购买第 1 个水果，你可以免费获得第 2 个水果。 免费获得第 2 个水果。 用 prices[2] = 1 个金币购买第 3 个水果，你可以免费获得第 4 个水果。 免费获得第 4 个水果。 示例 3：\n输入：prices = [26,18,6,12,49,7,45,45]\n输出：39\n解释：\n用 prices[0] = 26 个金币购买第 1 个水果，你可以免费获得第 2 个水果。 免费获得第 2 个水果。 用 prices[2] = 6 个金币购买第 3 个水果，你可以免费获得第 4，5，6（接下来的三个）水果。 免费获得第 4 个水果。 免费获得第 5 个水果。 用 prices[5] = 7 个金币购买第 6 个水果，你可以免费获得第 7 和 第 8 个水果。 免费获得第 7 个水果。 免费获得第 8 个水果。 请注意，即使您可以免费获得第 6 个水果作为购买第 3 个水果的奖励，但您购买它是为了获得其奖励，这是更优化的。\n提示：\n1 \u003c= prices.length \u003c= 1000 1 \u003c= prices[i] \u003c= 105\n解题思路 先看看 case1 ， 如果我们购买了 0 ，这个时候有两个选择\n免费获取 1 ，我们只能购买 2 , 总花费是 5 不免费获取 1 ， 我们免费获取 2，总花费是 4 所以我们选择第二种方案，这种方案代价最低\n我们需要考虑的是，对于 dp[i] 我们定义其含义为 购买了 i 时，获取从 dp[i+1] 到 dp[2i] 的最小花费\n计算 dp[i] ，我们需要计算 j from [i+1] to [2i] 中的最小花费，在加上 price[i]\n\\[ \\text{dfs}(i) = \\text{prices}[i] + \\min_{j=i+1}^{2i+1} \\text{dfs}(j) \\]\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public int minimumCoins(int[] prices) { int n = prices.length; int[] memo = new int[(n + 1) / 2]; return dfs(1, prices, memo); } private int dfs(int i, int[] prices, int[] memo) { if (i * 2 \u003e= prices.length) { return prices[i - 1]; // i 从 1 开始 } if (memo[i] != 0) { // 之前算过 return memo[i]; } int res = Integer.MAX_VALUE; for (int j = i + 1; j \u003c= i * 2 + 1; j++) { res = Math.min(res, dfs(j, prices, memo)); } return memo[i] = res + prices[i - 1]; // 记忆化 } ","description":"","tags":["alg@dp"],"title":"每日一题20250124-LC2944","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9820250124-lc2944/"},{"categories":["Algorithm"],"content":"题目信息 1561. 你可以获得的最大硬币数目 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 有 3n 堆数目不一的硬币，你和你的朋友们打算按以下方式分硬币： 每一轮中，你将会选出 任意 3 堆硬币（不一定连续）。 Alice 将会取走硬币数量最多的那一堆。 你将会取走硬币数量第二多的那一堆。 Bob 将会取走最后一堆。 重复这个过程，直到没有更多硬币。 给你一个整数数组 piles ，其中 piles[i] 是第 i 堆中硬币的数目。 返回你可以获得的最大硬币数目。 示例 1： 输入：piles = [2,4,1,2,7,8] 输出：9 解释：选出 (2, 7, 8) ，Alice 取走 8 枚硬币的那堆，你取走 7 枚硬币的那堆，Bob 取走最后一堆。 选出 (1, 2, 4) , Alice 取走 4 枚硬币的那堆，你取走 2 枚硬币的那堆，Bob 取走最后一堆。 你可以获得的最大硬币数目：7 + 2 = 9. 考虑另外一种情况，如果选出的是 (1, 2, 8) 和 (2, 4, 7) ，你就只能得到 2 + 4 = 6 枚硬币，这不是最优解。 示例 2： 输入：piles = [2,4,5] 输出：4 示例 3： 输入：piles = [9,8,7,6,5,1,2,3,4] 输出：18 提示： 3 \u003c= piles.length \u003c= 10^5 piles.length % 3 == 0 1 \u003c= piles[i] \u003c= 10^4 解题思路 第一个思路是按顺序取，维护一个大顶堆，一轮取 3 个，自己每次取第二个，实现完以后，第三个 case 没过，仔细看了一下题目，漏掉了第一个命题\n每一轮中，你将会选出 任意 3 堆硬币（不一定连续）。\n第三个 case 的最优解是 18 , 按第一种方式取的话只能取到 15\n仔细思考一下，由于 Alice 的选择一定是贪的，那么我们每次只能选到第二大元素，但是我们可以给 Bob 分配最小元素，这样我们的贪心策略才是最优解\n实现 我们首先对数组进行排序，然后通过双指针来分配元素中的最大最小值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public int maxCoins(int[] piles) { Arrays.sort(piles); int sum = 0; int flag = 0; int l = 0 , r = piles.length - 1; while(l \u003c= r){ if(flag == 0){ r--; flag = 1; }else if(flag == 1){ sum += piles[r]; r--; flag = 2; }else if(flag == 2){ l++; flag = 0; } } return sum; } ","description":"","tags":["alg@geeedy"],"title":"每日一题20250122","uri":"/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9820250122/"},{"categories":["Technolgic"],"content":"Summary 主要通过 raft 论文的解读，理解 raft 一致性算法\nRaft 是一种用来管理日志复制的一致性算法，脱胎于 Paxos 但是比 Paxos 更容易理解\n将一致性算法细分为了 3 个子问题，并对每个子问题进行了详细提供明确的说明\n选主 日志复制 安全性 论文的内容概述 复制状态机 Section2 通常的 RSM 是通过日志复制来实现的，而保证复制日志的一致性则依赖一致性算法，常见的一致性算法系统通常包括以下几点特性\n安全性，一般再不考虑拜占庭问题下，出现的 网络延迟、分区、丢包重复问题不会导致系统出现异常结果 高可用，多数节点存活状态下，系统可用 不依赖时间来保障一致性 多数一致性，少数响应缓慢节点不影响整体性能 Paxos 的问题 Section3 这部分主要介绍了 Paxos 在时间中的问题 Paxos 主要有两个障碍\n难以理解 即使是最简单的 Paxos 单决议的子集，都是难以理解的 没有为实际实现提供一个良好的基础 其次是复杂度很高，难以用于实践\nRaft 的设计目标 Section4 Raft 的设计目标\n为构建实际的实现提供良好的基础 可理解 Raft 为提高可理解性做出的两个方式\n细分问题 Leader Election（选主） Log replication (日志复制) Safety (安全性) Membership change (成员变更) 简化状态空间 Raft 一致性算法 Section5-8 评估Raft 与相关工作 Section9-10 Section9 主要通过一些数据证明 raft 的易于理解、正确性以及性能的说明\nSection10 主要是简单的介绍了一写与 raft 相关或类似的项目 VR ， zookeeper\nRaft 一致性算法 ATTACH Raft 算法概述 Raft 算法的关键属性\nRaft 保障下列特性在任何时刻都是有效的\nElection Safety: 任何一个 term 中，最多只有一个 Leader 可以被选出\nLeader Append-Only: Leader 不会覆写或删除任何日志 entry ，只允许追加 entry\nLog Matching : 如果两个日志 Entry 有相同的 index 和 term ,那么在此之前的日志是绝对一致的\nLeader Completeness: 如果一个日志 entry 在一个 term 中被提交，那么这条日志 entry 必然存在于更高序号的 term 的 Leader 的日志中\nState Machine Safety: 如果一个服务确认了给定所以的日志，其他服务绝对不会使用相同的索引\nRaft 一致性算法细分为了一下 3 个子问题\nLeader election: 当现有的 Leader 失败时，需要选举出一个新 Leader Log replication: Leader 必须接受来自客户端的日志条目，并将其复制到集群中，并保证其他日志与自己的日志保持一致。 Safety: 如果一个服务确认了给定所以的日志，其他服务绝对不会使用相同的索引 Raft basic ATTACH 状态 在任意时刻，Server 只有 leader , follover , candidate 三种状态\nfollower: 不处理请求，只响应来自 leader 与 candidate 的请求 leader: 处理所有来自 client 的请求 candidate: 在竞选新 leader 的情况出现 状态变更图\nterm Raft 将时间划分为任意长度的任期。\n通过 terms 作为一个逻辑时钟，服务间的每次交互都会交换各自的 term ，当 term 比对方大时，会更新自己的 term 为较大值\nRPC RequestVoteRPCS\nAppendEntriesRPCs\nInstallSnapshotRPC\n通过并行请求提高效率\nRaft Leader Election Leader 通过保持心跳来与 Follwer 同步状态，当出现 election timeout ，即在一个周期时间内，没有收到来自 Leader 的心跳，即认为 Leader 不可达并发起新一轮的选举\n选举开始时，follower 会增加自己的 term 并将自己转为 candidate,通过 RequestVote RPC 进行投票后，会有三种情况\n赢得选举 其他服务赢得选举 选举超时，没有服务赢得选举 通过多数原则及先到先得原则保证最多只有一个 candidate 可以赢得选举。\ncanidate 处理 RPC 请求的情况\nown term \u003c rpc term 时，恢复到 follower 状态\nown term \u003e rpc term 时，拒绝请求\n新一轮选举\nRaft 通过随机超时选举时间来解决冲突，不采用随机化会导致类似饥饿的问题\nRaft Log Replication leader 选举 日志复制采用了类似 zk 的全局主写入方案，能保证全局一致性\n一旦选举出领导者，领导者开始处理客户端请求，并将命令追加到日志中。 领导者通过 AppendEntries RPC 将日志条目复制到跟随者。 当日志条目在大多数服务器上安全复制后，领导者将该命令应用到其状态机，并返回结果给客户端。\n日志提交 commited 机制 ，当 Leader 提交了一个日志 Entry ，那么 raft 会保证该 Entry 的持久化，并且最终会应用于所有可用的服务\n日志条目在 Leader 将其复制到大多数服务器后被提交。一旦提交，它将是持久的，并最终被所有状态机应用。 领导者跟踪最高的提交日志索引，并在未来的 RPC 中包含该索引，以确保跟随者更新。\n日志匹配属性： 如果两个日志条目具有相同的索引和任期，它们存储相同的命令。 如果两个日志条目具有相同的索引和任期，它们在所有前面的条目上是相同的，从而确保一致性。 AppendEntries 进行一致性检查，确保维持这一属性。\n处理崩溃与不一致： 如果跟随者的日志与领导者的日志不一致，领导者会通过强制跟随者的日志与自己的日志一致来解决不一致问题。领导者会找到两者日志匹配的最新位置，删除跟随者日志中不匹配的条目，并发送自己的日志条目覆盖它们。\nLeader 维护一个 nextIndex，指示下一条将发送给跟随者的日志索引。当跟随者的日志不一致时， AppendEntries 检查会失败，领导者会递减 nextIndex 并重试，直到日志一致。\nRaft Safety Raft 协议需要确保所有的领导者都已提交该条目，这样才能确保日志的一致性。如果一个条目来自之前的任期，它可能还未被所有服务器接受，因此不能立即认为它已提交。这个问题是 Raft 协议确保一致性和安全性的关键部分，尤其在处理领导者崩溃和恢复时需要特别注意。\nRaft 不会通过计数副本的方式提交来自旧任期的日志条目。只有当前领导者任期中的日志条目，才会通过副本计数的方式提交。\n关于安全性的证明 这部分感兴趣的可以自己看看原文\nRaft Follower 与 Candidate 崩溃 主要说了 Follower 于 Candidate 崩溃时的策略，相对 Leader 崩溃的会简单不少\n重试，直到服务恢复正常 当业务完成后 crash ， 通过 幂等性重试 解决 Raft Timing 时间计算的 方式\nboardcastTime , avg of All(req,resp) , 0.5 ~ 20 ms electionTimout , 10 ~ 500ms MTBF , avg of failures Raft cluster membership chageu ATTACH 通过一致性算法自动处理配置变更 在变更过程中无法保障原子行修改，在切换过程中，集群会分裂成两个独立的大多数集群（Old，New）\nRaft 采用了一种两阶段协议来保障安全性\njoint consenus:\n日志在 \\( C_{\\text{old}} \\) 与 \\( C_{\\text{new}} \\) 两个配置集群间都进行复制 任何来配置内的服务都可以作为 Leader 需要在新老配置的服务中都赢得大多数同意 会引入 3 个问题\n新机器没有任何日志，会导致很长的 gap 时间 新加入的机器没有选举权，直到日志追平 Leader 不在新配置中 在\\( C_{\\text{old}} \\)被确认阶段，会被迫转为 follower ，复制日志，但不会把自己计入大多数中，等待新的 Leader 被移除的服务有可能分裂集群 服务在最小选举超时时间内，没有收到当前 Leader 的确认，不会跟新 term Raft Log Compaction ATTACH 保存当前的状态值，以当前值开始重新进行日志的写追加\n快照在集群间的处理难度\nfollower 自行处理 统一由 Leader 处理 Snapshot 的同步场景导致网络与程序延迟 Leader 的复杂性 以及 2 个性能相关的问题\n快照频率 写入快照的时间占用，COW 方案 Raft Client interaction 客户端在启动时，会随机选择一个服务，如果该服务不是 Leader ，会拒绝请求并返回其所知的最新的 Leader 信息\n线性化语意 线性化语义（linearizable semantics）是分布式系统中使用的一种一致性模型，特别是在并发操作的上下文中。简单来说，线性化确保对共享资源（如变量或数据结构）的每个操作看起来都在某个时间点瞬间执行，并且在其调用和响应之间的某个时刻执行。线性化的关键点如下：\n瞬时操作：每个操作必须看起来在其调用和响应之间的某个时间点瞬间执行，这个“时间点”被认为是操作完成的时刻。\n操作顺序：资源上的操作必须遵循一个全局顺序，该顺序与它们的调用顺序一致。即使操作是并发执行的或在分布式系统中乱序执行，它们的结果也必须与某种顺序的执行一致。\n原子性：每个操作看起来是原子的，即要么完全执行，要么完全不执行（没有部分结果）。\n实时一致性：如果一个操作的响应在另一个操作的调用之前收到，那么第一个操作的结果必须对第二个操作可见，并且第二个操作开始时能看到第一个操作的结果。\n通过顺序号来保证\nRead-only 实现的两个必要措施 Leader 需要知道最新的提交 Entry no-op entry 处理 Read-only 请求前确保自己没有被罢免 通过心跳机制来保障 ","description":"","tags":["distribute"],"title":"Raft 算法论文解读","uri":"/posts/raft-%E7%AE%97%E6%B3%95%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"},{"categories":["Algorithm"],"content":"Summary 回溯算法中的排列与组合\n框架模板 回溯算法在解决排列和组合问题时，两者的主要区别在于元素的顺序是否重要，以及结果中是否允许重复选取相同元素。\n排列 (Permutation) 顺序重要：在排列中，元素的顺序会影响结果。例如，[1, 2] 和 [2, 1] 被视为不同的排列。 典型问题：求数组的全排列、给定数列的不同排列方式等。 特点：需要考虑每个元素在每个位置的可能性，通常通过标记来避免重复选取已使用的元素。 组合 (Combination) 顺序不重要：在组合中，元素的顺序不影响结果。例如，[1, 2] 和 [2, 1] 被视为相同的组合。 典型问题：求数组的所有子集、选出若干个元素的组合等。 特点：只需要关心某个元素是否被选中，不需要考虑顺序，通常可以通过限制递归的起始位置来避免重复组合。 排列代码模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void backtrack(List\u003cList\u003cInteger\u003e\u003e res, List\u003cInteger\u003e tempList, int[] nums, boolean[] used) { if (tempList.size() == nums.length) { res.add(new ArrayList\u003c\u003e(tempList)); } else { for (int i = 0; i \u003c nums.length; i++) { if (used[i]) continue; // 跳过已使用的元素 used[i] = true; tempList.add(nums[i]); backtrack(res, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); } } } 组合框架模板\n1 2 3 4 5 6 7 8 void backtrack(List\u003cList\u003cInteger\u003e\u003e res, List\u003cInteger\u003e tempList, int[] nums, int start) { res.add(new ArrayList\u003c\u003e(tempList)); for (int i = start; i \u003c nums.length; i++) { tempList.add(nums[i]); backtrack(res, tempList, nums, i + 1); // 从下一个元素开始 tempList.remove(tempList.size() - 1); } } 排列中元素的顺序重要，通常使用一个 boolean[] used 数组来跟踪已选择的元素。 组合中元素的顺序不重要，使用 start 参数控制递归的起始位置，以避免重复的组合。 解题 46. 全排列 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { private List\u003cList\u003cInteger\u003e\u003e res; private List\u003cInteger\u003e tmp; public List\u003cList\u003cInteger\u003e\u003e permute(int[] nums) { res = new ArrayList\u003c\u003e(); tmp = new ArrayList\u003c\u003e(); int n = nums.length; boolean[] used = new boolean[n]; backtrack(n,nums,used); return res; } private void backtrack(int n ,int[] nums,boolean[] used){ if(tmp.size() == n){ res.add(new ArrayList\u003c\u003e(tmp)); } for(int i = 0 ; i \u003c nums.length; i++){ if(!used[i]){ used[i] = true; tmp.add(nums[i]); backtrack(n,nums,used); used[i] = false; tmp.remove(tmp.size()-1); } } } } 77. 组合 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { private List\u003cList\u003cInteger\u003e\u003e res; private List\u003cInteger\u003e tmp; public List\u003cList\u003cInteger\u003e\u003e combine(int n, int k) { res = new ArrayList\u003c\u003e(); tmp = new ArrayList\u003c\u003e(); backtrack(n,k,1); return res; } private void backtrack(int n , int k ,int start){ //剪枝操作 if(tmp.size() + (n-start+1) \u003c k){ return; } if(tmp.size() == k){ res.add(new ArrayList\u003c\u003e(tmp)); } for(int i = start ; i \u003c= n ; i++){ tmp.add(i); backtrack(n,k,i+1); tmp.remove(tmp.size() - 1); } } } 216. 组合总和 III - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { private List\u003cInteger\u003e path; private List\u003cList\u003cInteger\u003e\u003e res; public List\u003cList\u003cInteger\u003e\u003e combinationSum3(int k, int n) { path = new ArrayList\u003c\u003e(); res = new ArrayList\u003c\u003e(); backtrack(k,n,1,0); return res; } private void backtrack( int k , int n,int cur, int sum ){ if (sum \u003e n) { // 剪枝操作 return; } if(path.size() == k \u0026\u0026 sum == n){ res.add(new ArrayList\u003c\u003e(path)); } for(int i = cur ; i \u003c= 9 - (k-path.size()) + 1; i++){ path.add(i); backtrack(k,n,i+1,sum + i); path.remove(path.size()-1); } } } ","description":"","tags":null,"title":"算法日记-03","uri":"/posts/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-03/"},{"categories":["Algorithm"],"content":"Summary 滑动窗口的一种算法模板\n模板 滑动窗口的一种算法模板\n1 2 3 4 5 6 7 8 9 //外层循环扩展右边界，内层循环扩展左边界 for (int l = 0, r = 0 ; r \u003c n ; r++) { //当前考虑的元素 while (l \u003c= r \u0026\u0026 check()) {//区间[left,right]不符合题意 //扩展左边界 } //区间[left,right]符合题意，统计相关信息 } 3. 无重复字符的最长子串 3. 无重复字符的最长子串 - 力扣（LeetCode）\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。\n本题套用模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public int lengthOfLongestSubstring(String s) { char[] cs = s.toCharArray(); int max = 0; Set\u003cCharacter\u003e set = new HashSet\u003c\u003e(); for(int l = 0 , r = 0 ; r \u003c cs.length ; r++){ char c = cs[r]; while(set.contains(c)){ set.remove(cs[l]); l++; } set.add(c); max = Math.max(max,r-l+1); } return max; } 长度最小的子数组 209. 长度最小的子数组 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 public int minSubArrayLen(int target, int[] nums) { int sum = 0; int minLength = Integer.MAX_VALUE; for (int l = 0, r = 0; r \u003c nums.length; r++) { sum += nums[r]; while (l \u003c r \u0026\u0026 sum \u003e= target) { sum -= nums[l]; l++; minLength = Math.min(minLength, r - l); } } return minLength == Integer.MAX_VALUE ? 0 : minLength; } ","description":"","tags":null,"title":"刷题日记-02","uri":"/posts/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-02/"},{"categories":["Algorithm"],"content":"206.反转链表 206. 反转链表 - 力扣（LeetCode）\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n两种解法\n递归 递归的函数可以看成一个已经实现了的函数 reverse ，我们通过两个节点，一个是 pre 一个 cur ，反转链表其实是交换了两个节点连接的指向，我们在递归函数中，只翻转单相的连接就行，就是先 反转cur 跟 pre ，然后把反转后的 cur 跟 next 在进行反转，这是后序的操作逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 public ListNode reverseList(ListNode head) { return reverse(null,head); } private ListNode reverse(ListNode pre , ListNode cur){ if(cur == null){ return pre; } ListNode next = cur.next; cur.next = pre; return reverse(cur, next); } 迭代 迭代需要维护两个指针，迭代过程中，注意操作顺序就行,先考虑最简单的情况，null -\u003e 1 -\u003e 2 , 分别对应三个指针 pre , cur , next , 我们把 cur.next 先指向 pre , 然后迭代 pre 跟 cur\n1 2 3 4 5 6 7 8 9 10 11 public ListNode reverseList(ListNode head) { ListNode pre = null; ListNode cur = head; while(cur != null){ ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; } return pre; } 215. 数组中的第K个最大元素 215. 数组中的第K个最大元素 - 力扣（LeetCode）\n给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。\n请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。\n由于堆的建堆与删除的平均时间是 O(logn) 不能满足 O(n) 的时间复杂度\n1 2 3 4 5 6 7 8 9 10 11 public int findKthLargest(int[] nums, int k) { PriorityQueue\u003cInteger\u003e queue = new PriorityQueue\u003c\u003e(k,(x,y) -\u003e y-x); for(int i = 0 ; i \u003c nums.length ; i++){ queue.offer(nums[i]); } int res = 0; while(k-- \u003e0){ res = queue.poll(); } return res; } 基于快排的解决方案\nquick 的基本思路，我们随机选择一个切分点，将切分点排定，保证切分元素的 左边元素都小于切分点，右边元素大于切分点,递归的排定每个子分区，最后整个数组排定\n1 2 3 4 5 6 7 8 private void quickSort(int[] nums, int lo, int hi) { if (lo \u003e= hi) { return; } int p = partition(nums, lo, hi); quickSort(nums, lo, p-1); quickSort(nums, p + 1, hi); } 关键在于 切分元素的选择\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private int partition(int[] nums, int lo, int hi) { int i = lo, j = hi + 1; int v = nums[i]; // 切分元素选择 while (true) { while (nums[i++] \u003c v) { if (i == hi) { break; } } while (nums[j--] \u003e v) { if (j == lo) { break; } } //当 i \u003e= j 的时候，退出循环 if (i \u003e= j) { break; } swap(nums, i, j); } swap(nums, lo, j); return j; } 回到题目中，我们对快排做个改造，\n我们需要对切分逻辑做一下修改，保证倒序实现 当我们切分点 p 等于 k 的时候，我们的题目就排定了直接返回，如果 p \u003c k 则下一步排定右侧，如果 p \u003e k 则排定左侧 最后代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public int findKthLargest(int[] nums, int k) { return quickSort(nums, 0, nums.length - 1, k - 1); } private int quickSort(int[] nums, int lo, int hi, int k) { if (lo \u003e= hi) { return nums[k]; } int p = partition(nums, lo, hi); if (p == k) { return nums[p]; } else if (p \u003c k) { return quickSort(nums, p + 1, hi, k); } else { return quickSort(nums, lo, p - 1, k); } } private int partition(int[] nums, int lo, int hi) { int i = lo, j = hi + 1; int v = nums[i]; // 切分元素选择 while (true) { while (nums[++i] \u003e v) { if (i == hi) { break; } } while (nums[--j] \u003c v) { if (j == lo) { break; } } if (i \u003e= j) { break; } swap(nums, i, j); } swap(nums, lo, j); return j; } private void swap(int[] nums, int x, int y) { int tmp = nums[x]; nums[x] = nums[y]; nums[y] = tmp; } ","description":"","tags":null,"title":"刷题日记-01","uri":"/posts/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-01/"},{"categories":["Algorithm"],"content":"Summary BST 二叉搜索树，是一颗二叉树，其中的每个节点的值，都大于 左子树的任意节点 而小于 右子树的任意节点\n基本结构 BST 是一个数据形态相对特殊的二叉树，二叉树本质是一种特化的链表结构，同时持有左右两个节点的指针，是一种天然的递归结构，\n1 2 3 4 5 class Node { int val; Node left; Node right; } 扩展结构，我们针对 Node 的基本结构，进行一下扩展，支持 Key Value 格式的数据，更类似我们的 Map 结构，同时加入一个 size 属性，表示当前节点的子节点数量\n我们利用泛型的上界来强制 K 必须是 Comparable 的字类\n1 2 3 4 5 6 7 class Node\u003cK extend Comparable\u003cK\u003e , V\u003e { K key; V value; Node\u003cK extend Comparable, V\u003e left; Node\u003cK extend Comparable,V\u003e right; int size; } 算法抽象 我们先最基本的需要提供 3 个抽象操作， find() , insert() , remove()\n并且树内不允许存在重复 Key , 相同 Key 的 insert 操作，会覆盖之前的 value\n1 2 3 4 5 interface Bst\u003cK extend Comparable\u003cK\u003e,V\u003e { Value find(Key k); void insert(Key k,V v); void remove(Key k); } 以上我们的准备工作基本完成了，后面的操作需要的时候我们在回来处理，基本模板如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 interface Bst\u003cK extends Comparable\u003cK\u003e, V\u003e { V find(K k); void insert(K k, V v); void remove(K k); } public class BstTree\u003cK extends Comparable\u003cK\u003e, V\u003e implements Bst\u003cK, V\u003e { private Node root; private class Node { K k; V v; Node left; Node right; int size; } } 算法实现 find(K k) 第一步先实现搜索算法 find(K k) , 如果我们找到 k ，则返回对应的 value ，否则我们返回 null , BST 的搜索是最简单的，我们从根节点开始搜索利用 k 与 Node 节点的 kn 进行比较，如果 k \u003c kn , 则向左子树搜索，如果 k \u003e kn 则向右子树搜索，如果 k = kn ，则返回节点 value\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Override public V find(K k) { final Node node = find(root, k); if (node != null) { return node.v; } else { return null; } } private Node find(Node n, K k) { if (n == null) { return null; } int cmp = k.compareTo(n.k); if (cmp \u003c 0) { return find(n.left, k); } else if (cmp \u003e 0) { return find(n.right, k); } else { return n; } } insert(K k,V v) 插入也是比较简单的逻辑，我们从 root 节点开始，利用与 find 类似的逻辑找到可以插入节点的位置，构造一个新节点，然后进行插入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Override public void insert(K k, V v) { insert(root, k, v); } private Node insert(Node node, K k, V v) { if (node == null) { return new Node(k, v); } int cmp = k.compareTo(node.k); if (cmp \u003c 0) { node.left = insert(node.left, k, v); } else if (cmp \u003e 0) { node.right = insert(node.right, k, v); } else { node.v = v; } //插入的时候，需要更新一下 size node.size = size(node.left) + size(node.right) + 1; return node; } remove 实现 remove 是 BST 实现中最复杂的操作，如果要删除的节点，同时拥有左右子节点的情况，光想想就会很复杂\n我们先来思考一个简单的特殊操作，找到树中的最大/最小值，删除树中的最大最小值\n我们代码中只实现删除最小值的方式，如上图，我们从 root 出发，在左子树上遍历，在递归的过程中，我们更新左子树的指针为删除后返回的节点\n左子树不为空，则不是最小值，则继续遍历左子树 左子树为空，则返回右子树；右子树不为空，则父节点的左指针指向了删除节点的右子树；右子树为空，则父节点的左指针指向了null 1 2 3 4 5 6 7 8 9 10 11 12 public void delMin() { delMin(root); } private Node delMin(Node node) { if (node.left == null) { return node.right; } node.left = delMin(node.left); node.size = size(node.left) + size(node.right) + 1; return node; } 现在从特殊到一般情况，考虑删除任意节点\n从逻辑上讲，我们首先需要递归的找到需要删除的目标 key\n先思考一下 BST 的一个特性，就是中序遍历是有序的，如下图，中序遍历的就是 [3,4,5,21,20,22,16,27,28,32] ,假如我们删除 5 ，那么 5 在树中的位置，需要一个元素填充过来，继续保证二叉树的有序性，很显然，这个节点放 4,19 是可以继续保证节点的有序性的，这俩节点分别是被删除节点的前驱节点与后继节点\n现在我们考虑一下如何删除\n我们先递归的从 root 开始，找到删除的目标节点 x 我们用一个临时变量 tmp 来指向 x 将 x.right 指向 delMin 的返回值，即 删除后所有节点大于删除节点的子二叉树 将 x.left 指向 tmp.left ，即 删除后所有节点小于删除节点的子二叉树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Override public void remove(K k) { remove(root, k); } private Node remove(Node x, K k) { final int cmp = x.k.compareTo(k); if (cmp \u003c 0) { //IMPORTANT 这里是递归的设置 x 节点的 left 指针，不能直接 return x.left = remove(x.left, k); } else if (cmp \u003e 0) { x.right = remove(x.right, k); } else { //找到了 要删除的节点 if (x.left == null) { //左子树为空，直接返回右子树 图中 删除 3 的 case return x.right; } if (x.right == null) { //右子树为空，直接返回左子树 图中删除 22 的 case return x.left; } //左右都不为空 Node tmp = x; x = findMin(x.right); x.right = delMin(x.right); x.left = tmp.left; } x.size = size(x.left) + size(x.right) + 1; return x; } 总结 以上基本完成了一个 BST 的基本实现，BST 被诟病的问题是平衡性的问题，极端情况下，会退化为链表，生成上很少有实际使用，但是作为一种基础数据结构，是简单且在大部分情况下足够高效的，效率上可能比不过红黑树，但是实现复杂度上，BST 要简单很多当然使用 Java 的情况下，我们基本不太可能自己构建一个 BST ，内置的 HashMap,TreeMap 已经实现了很高效的查找表，不过还是需要理解算法的基本逻辑与做法；\n一个小💡\nBST 的问题是不平衡导致的效率退化，那么我是不是可以来定期的对 BST 进行一个异步的 rebalance ？来周期性的保证树的平衡性，保证算法效率不会退化的太过分\n但是很显然如果要异步处理，每次 rebalance 都需要 O(n) 的时间与空间，还需要考虑 rebalance 期间的数据读写的同步问题，这样实现的复杂度又很高了，不如找到一种更高效的平衡方式，把 rebalance 的操作均摊到每次操作中\n完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 interface Bst\u003cK extends Comparable\u003cK\u003e, V\u003e { V find(K k); void insert(K k, V v); void remove(K k); int size(); void delMin(); V findMin(); } public class BstTree\u003cK extends Comparable\u003cK\u003e, V\u003e implements Bst\u003cK, V\u003e { private Node root; @Override public V find(K k) { final Node node = find(root, k); if (node != null) { return node.v; } else { return null; } } private Node find(Node n, K k) { if (n == null) { return null; } int cmp = k.compareTo(n.k); if (cmp \u003c 0) { return find(n.left, k); } else if (cmp \u003e 0) { return find(n.right, k); } else { return n; } } @Override public void insert(K k, V v) { insert(root, k, v); } private Node insert(Node node, K k, V v) { if (node == null) { return new Node(k, v); } int cmp = k.compareTo(node.k); if (cmp \u003c 0) { node.left = insert(node.left, k, v); } else if (cmp \u003e 0) { node.right = insert(node.right, k, v); } else { node.v = v; } node.size = size(node.left) + size(node.right) + 1; return node; } @Override public void remove(K k) { remove(root, k); } private Node remove(Node x, K k) { final int cmp = x.k.compareTo(k); if (cmp \u003c 0) { //IMPORTANT 这里是递归的设置 x 节点的 left 指针，不能直接 return x.left = remove(x.left, k); } else if (cmp \u003e 0) { x.right = remove(x.right, k); } else { //找到了 要删除的节点 if (x.left == null) { //左子树为空，直接返回右子树 图中 删除 3 的 case return x.right; } if (x.right == null) { //右子树为空，直接返回左子树 图中删除 22 的 case return x.left; } //左右都不为空 Node tmp = x; x = findMin(x.right); x.right = delMin(x.right); x.left = tmp.left; } x.size = size(x.left) + size(x.right) + 1; return x; } @Override public int size() { return size(root); } @Override public void delMin() { delMin(root); } private Node delMin(Node node) { if (node.left == null) { return node.right; } node.left = delMin(node.left); node.size = size(node.left) + size(node.right) + 1; return node; } @Override public V findMin() { if (root == null) { return null; } return findMin(root).v; } public Node findMin(Node n) { if (n.left == null) { return n; } return findMin(n.left); } private int size(Node n) { return n.size; } private class Node { K k; V v; Node left; Node right; int size; public Node(K k, V v) { this.k = k; this.v = v; this.size = 1; } } } Reference 实现思路参考了 《算法（第四版）》中 二叉查找树 的部分，书中的相关章节讨论了很多关于 BST 效率的问题，其他章节对一些基础算法都有详细的介绍与解析，以及丰富的测试用例与习题，推荐指数：🌟🌟🌟🌟🌟\n这个算法的实现，可以解决下列\n701. 二叉搜索树中的插入操作 - 力扣（LeetCode） 450. 删除二叉搜索树中的节点 - 力扣（LeetCode） 669. 修剪二叉搜索树 - 力扣（LeetCode） 108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）\n","description":"","tags":null,"title":"从 0 构造一个 BST","uri":"/posts/%E4%BB%8E-0-%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA-bst/"},{"categories":["Reading"],"content":"因为之前的一些接触，对某些架构师的印象不是很好，纯 ppter，对架构的理解也过于片面，认为也非就是做一些技术选型，画一个好看的ppt 跟老板汇报\n通篇看下来，自己之前的认知是有些狭隘了，一个开发人员，在日常的编码中，实际上无时无刻不在接触架构，良好的代码结构与设计，就是一个好架构，事实上的整洁架构，就是整洁的代码设计；\n软件设计原则 如果把 solid 当作八股文则 solid 完全失去了意义，这些原则看起来非常简单 但是践行这些原则 需要的不是生搬硬套 而是根据原则能进行取舍，在应用中真正的用这些原则做到解耦和， 其实是一件比较困难的事 而这 也不只是单纯的靠编程经验就能做到的\nSOLID 的基本原则很简单，每一条看起来都简单到不能再简单，两句话就能解释明白，\nSRP: 单一职责原则，一个 OCP: 开闭原则 LSP: 里氏替换原则 ISP：接口隔离原则 DIP：依赖反转原则 作者用了大半本书的内容来说明诠释这些原则，用具体的实际情况来说明我们如何更好的编码，如何进行取舍，如何做架\n如果我们在在crud 的过程中能反复推敲，思考与抽象，那么能带来的帮助与提升，相信会非常之大\n说回本书，无论个人目标是否是称为一个架构师 作为一个开发人员确实应该应该多读几遍\n","description":"","tags":null,"title":"读《架构整洁之道》","uri":"/posts/%E8%AF%BB%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"},{"categories":["Technolgic"],"content":"Summary 一次用 Java 处理 heif 格式文件的碎碎念\n背景 在维护我司的一个文档处理服务，主要是功能是把各种类型的文件，统一转成 pdf 添加水印，然后前端通过通过 pdfview 统一渲染 pdf ，实现各种文件在线预览的功能\n底层用到的服务比较多，大部分文档是通过 openoffice 来实现，各种类型的图片资源是通过 itext 来支持的，但是 itext 的 ImageData 没法支持 heif 格式。需要单独支持一下 heif 转 pdf 功能\n过程 先测试了下 openoffice 跟 itext ，发现确实不能直接支持那剩下的方案优先考虑社区开源的 java 方案\n但是看下来，也没有 pure java 的实现\nTwelveMonkeys 是一个 Java 图片类型处理库，但是现在没有支持 heif 类型的图片\nharaldk/TwelveMonkeys#440 HEIF support\n看起来除非有人愿意实现或者资金支持，否则作者自己应该不会进行 HEIF 的支持了\n然后 issue 里提到的 NightMonkeys 是基于 libheif 实现的，但是要求 Java22+ , 线上代码还停留在祖传的 Java8 ，这个库也没法直接用\nGitHub - gotson/NightMonkeys: Additional plug-ins and extensions for Java’s I…\n那么基本就剩下 JNI 跟 调用命令两个方案了，相比之下，调用命令可能实现更简单一些，问题就只剩下怎么把 libheif 打入镜像了\nlibheif 底层依赖 libde265\n由于各种网络环境的限制，已经一些其他，打镜像可谓是一波三折\n基础镜像是一个基于 centos7\n构建机器访问外网也有限制，没法直接通过 yum 安装\n转而尝试自己编译，编译的时候，发现 yum 安装的 cmake 是 2.x ，编译 libheif 需要 cmake 3.21 以上\n又需要手动安装 cmake 好在 cmake 有提供现成的 .sh 脚本，直接加入到镜像里执行即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 FROM baseimage MAINTAINER xxx USER root COPY repo.sh /root/repo.sh RUN sh /root/repo.sh RUN yum-config-manager --disable updates RUN yum makecache RUN yum groupinstall \"Development Tools\" -y RUN yum install libjpeg-turbo-devel libpng-devel libtiff-devel -y COPY cmake-3.29.8-linux-x86_64.sh /root/cmake-3.29.8-linux-x86_64.sh RUN chmod +x /root/cmake-3.29.8-linux-x86_64.sh RUN /root/cmake-3.29.8-linux-x86_64.sh --prefix=/usr/local --skip-license RUN mkdir \"/root/heif/\" COPY heif.sh /root/heif/heif.sh COPY libde265-1.0.15.tar.gz /root/heif COPY libheif-1.18.2.tar.gz /root/heif RUN sh /root/heif/heif.sh 然后就是编译安装 libde265 以及 libheif\n比较坑的是 ld 部分，不知道为啥这个镜像没法加载 /usr/local/lib 以及 /usr/local/lib64 下的动态库，导致命令安装成功，但是执行会报错，提示动态库加载不到\n后来单独设置了一下，把 /usr/local/lib 以及 /usr/local/lib64 都加入到 ld 的文件夹下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 base=/root/heif/ cd $base tar zxvf libde265-1.0.15.tar.gz tar zxvf libheif-1.18.2.tar.gz cd $base/libde265-1.0.15 ./autogen.sh ./configure make \u0026\u0026 make install echo \"/usr/local/lib\" \u003e /etc/ld.so.conf.d/lib256.conf cd $base/libheif-1.18.2 mkdir build cd build cmake --preset=release .. make \u0026\u0026 make install echo \"/usr/local/lib64\" \u003e /etc/ld.so.conf.d/libheif.conf ldconfig 构建好的镜像就加入了 heif-convert 命令，在 java 程序中，直接使用 ProcessBuilder 调用 heif-convert 即可\n思考 这种方案并不能说是一个好方案，依赖底层环境，这种方案，换个环境就是个坑，但是在 docker 的加持下，这种方案可能算是一种比较快速的解决方案\n整个过程中，确实没少问 GPT ，技术类问题， GPT 也不是真全知全能，也会睁着眼睛说瞎话，这个在使用的过程中，是需要自己去甄别测试的，但是确实能节约一些搜索时间。现在 GPT 对我来说差不多能替代 70% 在搜索引擎上的使用场景\n","description":"","tags":["java"],"title":"Java 处理 heif 文件","uri":"/posts/java-%E5%A4%84%E7%90%86-heif-%E6%96%87%E4%BB%B6/"},{"categories":["Technolgic","technolgic"],"content":"Summary 记一次 CPU 高占用的排查过程\n由于 CodeCache 设置过小导致 C2 Compile 占用 CPU 的问题排查过程及原因分析\n事件 邮件服务收到告警，服务挂掉了，连到机器上查看发现服务还在运行，但是请求不能正常响应，服务卡死\nTOP 命令观察发现 CPU 持续维持在 200+ 以上，遂重启实例，重启实例以后，服务恢复，但是 CPU 占用还是会周期性的飙升到 100+\n但是很快 CPU 就会降低到正常值，过一会又飙起来了\n排查 CPU 高的基本过程 ATTACH 先用 top -Hp pid 查看线程信息\n\u003c_20240227_194922screenshot.png\u003e\n1 2 \u003e printf \"%x\\n\" 72 48 由于容器内没有 arthas ，先用 jstack 观察一下\n1 2 jstack 28 | grep \"0x48\" \"C2 CompilerThread1\" #9 daemon prio=9 os_prio=0 tid=0x00007fa258d0f000 nid=0x48 waiting on condition [0x0000000000000000] 发现是 C2 编译线程，而且那几个线程 id 都是连续的，大概率都是 C2 相关的几个线程\n1 2 3 4 5 6 7 8 9 jstack 28 | grep \"C2\" \"C2 CompilerThread7\" #15 daemon prio=9 os_prio=0 tid=0x00007fa258d24800 nid=0x4e waiting on condition [0x0000000000000000] \"C2 CompilerThread6\" #14 daemon prio=9 os_prio=0 tid=0x00007fa258d22800 nid=0x4d waiting on condition [0x0000000000000000] \"C2 CompilerThread5\" #13 daemon prio=9 os_prio=0 tid=0x00007fa258d20000 nid=0x4c waiting on condition [0x0000000000000000] \"C2 CompilerThread4\" #12 daemon prio=9 os_prio=0 tid=0x00007fa258d1e000 nid=0x4b waiting on condition [0x0000000000000000] \"C2 CompilerThread3\" #11 daemon prio=9 os_prio=0 tid=0x00007fa258d13800 nid=0x4a waiting on condition [0x0000000000000000] \"C2 CompilerThread2\" #10 daemon prio=9 os_prio=0 tid=0x00007fa258d11800 nid=0x49 waiting on condition [0x0000000000000000] \"C2 CompilerThread1\" #9 daemon prio=9 os_prio=0 tid=0x00007fa258d0f000 nid=0x48 waiting on condition [0x0000000000000000] \"C2 CompilerThread0\" #8 daemon prio=9 os_prio=0 tid=0x00007fa258d0d000 nid=0x47 waiting on condition [0x0000000000000000] 1 2 printf \"%d\\n\" 0x4e 78 所以定位到的是 C2 导致的 CPU 高占用\n分析 C2 是 JVM 用来进行 JIT 编译的线程，其过程是把 byteCode 编译为 nativeCode 的线程\n按道理是不应该长时间占用 CPU 资源来执行代码编译操作，找了一圈资料，发现基本有一下几个解决办法\n什么都不做 偶发的情况下，确实可以什么都不做，只会是一个短期的影响\n关闭分层编译 通过控制 --TieredCompilation 参数，可以强制关闭 C2 分层编译，但是肯定会对性能有影响\n这是作为最后的方案\n其他 预热等方案，但是与我遇到的实际情况不符还有一个利用 GBD 排查的，但是只是一个排查过程，可以给到一个启发思路，但是没有最终解决问题\n解决 在线下环境依然能稳定复现，想在线下环境装个 arthas , 偶然的情况下，突然发现 C2 占用是有一定规则的，每次有请求进来的时候，C2 就会开始执行编译\n可以稳定复现，于是排查 JVM 参数\n发现 -XX:ReservedCodeCacheSize=32m 修改到 512m 后 C2 的 CPU 占用降低\n问题探究 从现象看，应该跟 CodeCache 有关系，但是具体原因暂时不清楚，先跟踪一下 CodeCache 的情况\nID NAME GROUP PRIORITY STATE %CPU DELTA_TIME TIME INTERRUPTE DAEMON -1 C2 CompilerThread4 - -1 - 3.24 0.161 1:2.351 false true -1 C2 CompilerThread1 - -1 - 3.15 0.157 0:59.482 false true -1 C2 CompilerThread7 - -1 - 1.01 0.050 0:57.240 false true -1 C2 CompilerThread0 - -1 - 0.52 0.026 0:57.014 false true -1 C2 CompilerThread2 - -1 - 0.35 0.017 1:2.947 false true -1 C1 CompilerThread8 - -1 - 0.3 0.014 0:10.679 false true -1 C1 CompilerThread9 - -1 - 0.29 0.014 0:10.745 false true -1 C2 CompilerThread6 - -1 - 0.28 0.013 1:3.782 false true -1 C2 CompilerThread3 - -1 - 0.27 0.013 0:58.764 false true 309 SimplePauseDetectorThread_0 main 5 TIMED_WAIT 0.27 0.013 0:4.131 false true 310 SimplePauseDetectorThread_1 main 5 TIMED_WAIT 0.26 0.012 0:4.213 false true 311 SimplePauseDetectorThread_2 main 5 TIMED_WAIT 0.25 0.012 0:4.163 false true Memory used total max usage GC heap 1067M 4096M 4096M 26.05% gc.g1_young_generation.count 34 g1_eden_space 470M 948M -1 49.58% gc.g1_young_generation.time(ms) 2926 g1_survivor_space 128M 128M -1 100.00% gc.g1_old_generation.count 0 g1_old_gen 469M 3020M 4096M 11.45% gc.g1_old_generation.time(ms) 0 nonheap 175M 192M -1 90.94% code_cache 20M 28M 32M 64.11% metaspace 137M 145M -1 94.45% compressed_class_space 16M 18M 1024M 1.65% direct 136K 136K - 100.00% mapped 0K 0K - 0.00% Runtime os.name Linux os.version 3.10.0-1160.92.1.el7.x86_64 java.version 1.8.0_60 java.home /home/work/1.8.0_60/jre systemload.average 0.14 processors 16 timestamp/uptime Wed Feb 28 10:54:33 CST 2024/2052s ID NAME GROUP PRIORITY STATE %CPU DELTA_TIME TIME INTERRUPTE DAEMON -1 C2 CompilerThread0 - -1 - 15.87 0.793 0:57.807 false true -1 C2 CompilerThread6 - -1 - 11.8 0.590 1:4.372 false true -1 C2 CompilerThread1 - -1 - 3.85 0.192 0:59.675 false true -1 C2 CompilerThread2 - -1 - 1.74 0.086 1:3.034 false true -1 C2 CompilerThread4 - -1 - 1.37 0.068 1:2.420 false true -1 C2 CompilerThread7 - -1 - 1.14 0.057 0:57.297 false true -1 C2 CompilerThread3 - -1 - 0.8 0.040 0:58.804 false true -1 C2 CompilerThread5 - -1 - 0.53 0.026 0:56.526 false true 309 SimplePauseDetectorThread_0 main 5 TIMED_WAIT 0.3 0.014 0:4.146 false true 311 SimplePauseDetectorThread_2 main 5 TIMED_WAIT 0.29 0.014 0:4.177 false true 310 SimplePauseDetectorThread_1 main 5 TIMED_WAIT 0.28 0.014 0:4.227 false true -1 C1 CompilerThread9 - -1 - 0.27 0.013 0:10.759 false true Memory used total max usage GC heap 1067M 4096M 4096M 26.05% gc.g1_young_generation.count 34 g1_eden_space 470M 948M -1 49.58% gc.g1_young_generation.time(ms) 2926 g1_survivor_space 128M 128M -1 100.00% gc.g1_old_generation.count 0 g1_old_gen 469M 3020M 4096M 11.45% gc.g1_old_generation.time(ms) 0 nonheap 174M 192M -1 90.64% code_cache 19M 28M 32M 62.31% metaspace 137M 145M -1 94.45% compressed_class_space 16M 18M 1024M 1.65% direct 136K 136K - 100.00% mapped 0K 0K - 0.00%\n可以观察到的现象有一下几点\n系统空闲时，C2 还是会持续性的执行 JIT 编译，平均每个线程占用在 2% 左右 系统响应时，C2 线程的 CPU 会急剧上升 code_cache 一直在 50%-80% 之间浮动 C2 在容器里的线程数有 8 个，但是 CPU 实际在 POD 指定的 CPU 是 4 核心 调整 -XX:ReservedCodeCacheSize=1024m\nID NAME GROUP PRIORITY STATE %CPU DELTA_TIME TIME INTERRUPTE DAEMON 311 SimplePauseDetectorThread_0 main 5 TIMED_WAIT 0.21 0.010 0:3.103 false true 313 SimplePauseDetectorThread_2 main 5 TIMED_WAIT 0.21 0.010 0:3.077 false true 312 SimplePauseDetectorThread_1 main 5 TIMED_WAIT 0.2 0.009 0:3.164 false true 111 ee-ext-count-1 main 5 TIMED_WAIT 0.07 0.003 0:1.493 false false 82 Timer-for-arthas-dashboard-eaff5 system 5 RUNNABLE 0.07 0.003 0:1.088 false true -1 VM Periodic Task Thread - -1 - 0.05 0.002 0:1.112 false true -1 Unknown Thread - -1 - 0.05 0.002 0:1.054 false true 68 trace-collector main 5 TIMED_WAIT 0.04 0.002 0:1.264 false false 299 ee-ext-12 main 5 TIMED_WAIT 0.03 0.001 0:0.016 false false 47 activiti-acquire-timer-jobs main 5 TIMED_WAIT 0.03 0.001 0:0.370 false false 41 SimplePauseDetectorThread_0 system 9 TIMED_WAIT 0.02 0.001 0:0.636 false true 198 ee-ext-core-client-15 main 5 WAITING 0.02 0.001 0:0.015 false false Memory used total max usage GC heap 906M 4096M 4096M 22.13% gc.g1_young_generation.count 27 g1_eden_space 324M 948M -1 34.18% gc.g1_young_generation.time(ms) 2492 g1_survivor_space 128M 128M -1 100.00% gc.g1_old_generation.count 0 g1_old_gen 454M 3020M 4096M 11.10% gc.g1_old_generation.time(ms) 0 nonheap 202M 209M -1 96.85% code_cache 63M 63M 1024M 6.18% metaspace 124M 129M -1 95.97% compressed_class_space 15M 16M 1024M 1.47% direct 80K 80K - 100.00% mapped 0K 0K - 0.00% Runtime\nC2 的 CPU 显著降低 code_cache 维持的 63M 左右,会随着系统运行过程逐步增加\n问题很明显了， code_cache 不足会导致 C2 持续的编译操作,长时间占用 CPU ，导致程序响应缓慢\nOracle 官方文档中有如下一段内容\nKeep in mind that the codecache starts relatively small and then grows as needed as new methods are compiled.Sometimes compiled methods are freed from the codecache, especially when the maximum size of the codecache is constrained. The memory used by free methods can be reused for newly compiled methods, allowing additional methods to be compiled without growing the codecache further. – 15 Codecache Tuning (Release 8)\n意味这在当 限制了 codecache 的情况下，已经被编译的代码会被从 codecache 中释放出来，这大概就是当 ReservedCodeCacheSize=32m 的时候，C2 会持续性占用 CPU 的缘故，由于 codecache 最大值的限制，导致了 JIT 编译的代码被从 codecache 释放出来，而后有由于有新的请求，导致部分代码又通过 C2 执行 JIT 编译，如此往复循环，导致 C2 周期性的高占用 CPU\nRefrence Java C2 CompilerThread 长期占用 CPU 过高，如何查找原因？ | HeapDump性能社区 Analyzing a stuck HotSpot C2 compilation | by Vladimir Sitnikov | netcracker … jvm编译器参数及踩坑-弃用C2 | Zong’s blog 【问题排查系列】C2 compilerthread 带来的CPU抖动问题 - 掘金 聊聊jvm的Code Cache - 简书 15 Codecache Tuning (Release 8) Introduction to JVM Code Cache | Baeldung","description":"","tags":["java","jvm"],"title":"JVM C1 C2 占用 CPU 问题排查","uri":"/posts/jvm-c1-c2-%E5%8D%A0%E7%94%A8-cpu-%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"},{"categories":["emacs"],"content":"Summary 基于 emacs , ox-hugo , 集成 github pages , 搭建 blog\n基础环境准备 基本依赖环境是 `emacs` `hugo` `git`\nmacos 下 hugo 的安装 1 brew install hugo hugo 是基于 go 编写的，但是如果是非源码格式安装，应该不需要安装 go 依赖\n安装完成以后，使用 hugo version 检查\nhugo Quick Start 首先利用 hugo 创建一个站点, 这个命令默认创建的位置是当前命令执行的所在目录下的\n1 2 3 hugo new site my-blog cd my-blog git init 默认的 site 的目录结构如下\n├── archetypes │ └── default.md ├── assets ├── content ├── data ├── hugo.toml ├── i18n ├── layouts ├── static └── themes\n安装一个基本的 theme\n1 2 git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke echo \"theme = 'ananke'\" \u003e\u003e hugo.toml\" hugo server Watching for changes in /Users/zhangyang/github/my-blog/{archetypes,assets,content,data,i18n,layouts,static,themes} Watching for config changes in /Users/zhangyang/github/my-blog/hugo.toml, /Users/zhangyang/github/my-blog/themes/ananke/config.yaml Start building sites … hugo v0.122.0-b9a03bd59d5f71a529acb3e33f995e0ef332b3aa+extended darwin/arm64 BuildDate=2024-01-26T15:54:24Z VendorInfo=brew\nEN ——————-+—– Pages | 7 Paginator pages | 0 Non-page files | 0 Static files | 1 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0\nBuilt in 33 ms Environment: “development” Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server –disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop\nhugo 的基本环境搭建完成，访问 http://localhost:1313 查看一下效果\nhugo 的基本环境已经完成，配置以及主题等优化后续在看看怎么处理\nemacs + ox-hugo 我的 emacs 用的是 doom emacs 进行的配置， scp f f 编辑 init.el , 在 org 的配置中，启用 +hugo 标识\n1 (org +hugo) 执行\n1 doom sync 即可安装\n关键属性 ox-hugo 在 org-mode 中的关键属性有两个\nHUGO_BASE_DIR 以及 HUGO_SECTION\nHUGO_BASE_DIR 用来指定生成的 md 文件的 base_dir\n在 org 文件的头部设定好 HUGO_BASE_DIR\n执行 M-x org-hugo-exoirt-to-md 即可导出 org 文件到指定的 hugo 目录下\nox-hugo 工作流 ox-hugo 有支持以下两种工作流\n单 org 文件的工作流（推荐） 通过 org 的 subtree 来导出单独的文章 循环导出整个 subtree 一个 org 文件一篇文章的工作流 这样操作，就没法很好的利用 org 的标签，以及属性继承等特性，可以利用 关键字来标识草稿状态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ;; ox-hugo configuration (with-eval-after-load 'org-capture (defun org-hugo-new-subtree-post-capture-template () \"Returns `org-capture' template string for new Hugo post See `org-capture-templates' for more information.\" (let* ((title (read-from-minibuffer \"Post Title: \")) ;Prompt to enter the post title (fname (org-hugo-slug title))) (mapconcat #'identity `( ,(concat \"* TODO \" title) \":PROPERTIES:\" ,(concat \":EXPORT_FILE_NAME: \" fname) \":END:\" \"%?\\n\") ;Place the cursor here finally \"\\n\"))) (add-to-list 'org-capture-templates '(\"h\" ;`org-capture' binding + h \"Hugo post\" entry ;; It is assumed that below file is present in `org-directory' ;; and that it has a \"Blog Ideas\" heading. It can even be a ;; symlink pointing to the actual location of all-posts.org! (file+olp \"all-posts.org\" \"INBOX\") (function org-hugo-new-subtree-post-capture-template)) ) ) 基本的工作流 捕获到的博客想法，利用 capture 记录下来，\n利用 org-roam 整理笔记以输出内容，等文章整理完成以后，利用 org-refile-copy 把整个文章的内容 refile 到 all-post 下\n然后利用 :PROPERTIES: , 单独配置文章的 HUGO_SECTION 以及 EXPORT_FILE_NAME 等属性即可完成博客的编写\nall-post 的实际结构如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #+hugo_base_dir: path-to-hugo #+hugo_auto_set_lastmod: t * INBOX ** TODO POST1 IDEA :PROPERTIES: :EXPORT_FILE_NAME: export file :END: ** TODO POST2 IDEA * DONE FINISHED POST :@category:tag1:tag2: * DONE FINISHED POST2 :@category:tag1:tag2: :PROPERTIES: :EXPORT_FILE_NAME: 利用 emacs + hugo 搭建个人博客 :END: hugo 配置美化 主题美化 主题配置，准备环境中通过 `git sub module` 以及配置过相应的主题了，现在来切换一个新主题，美化一下 blog 以及优化一下配置\n1 2 3 cd hugo-dir git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt emacs hugo-toml 修改配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 baseURL = 'https://example.org/' title = 'your title' languageCode = 'zh-CN' languageName = \"简体中文\" hasCJKLanguage = true theme = 'LoveIt' [author] name = \"author info\" [menu] [[menu.main]] weight = 1 identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" [[menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false is required for LoveIt theme(https://github.com/dillonzq/LoveIt/issues/158) noClasses = false 更多主题 Complete List | Hugo Themes\nBlog 发布 利用 Github Pages 发布 Blog ATTACH 在 github 创建一个 `username.github.io` 的 `repo` 在仓库的 Settings -\u003e Pages 里修改 Build and Deployment 的 Source 修改为 GitHub Actions\n在本地的 hugo 代码库操作\n1 2 3 git remote add origin git@github.com:dreamkidd/dreamkidd.github.io.git git push --set-upstream origin main mkdir -p .github/workflows \u0026\u0026 touch .github/workflows/hugo.yaml 将一下内容粘贴到 `hugo.yaml` 中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 # Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: - main # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued. # However, do NOT cancel in-progress runs as we want to allow these production deployments to complete. concurrency: group: \"pages\" cancel-in-progress: false # Default to bash defaults: run: shell: bash jobs: # Build job build: runs-on: ubuntu-latest env: HUGO_VERSION: 0.122.0 steps: - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\ \u0026\u0026 sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Install Dart Sass run: sudo snap install dart-sass - name: Checkout uses: actions/checkout@v4 with: submodules: recursive fetch-depth: 0 - name: Setup Pages id: pages uses: actions/configure-pages@v4 - name: Install Node.js dependencies run: \"[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026\u0026 npm ci || true\" - name: Build with Hugo env: # For maximum backward compatibility with Hugo modules HUGO_ENVIRONMENT: production HUGO_ENV: production run: | hugo \\ --gc \\ --minify \\ --baseURL \"${{ steps.pages.outputs.base_url }}/\" - name: Upload artifact uses: actions/upload-pages-artifact@v2 with: path: ./public # Deployment job deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v3 提交一下代码，查看效果\nPS: 提交代码务必把 `.github` 与 `.gitmodules` 加入 git 仓库\n在 repo 的 Actions 里查看 workflow 的结果是否正常\n以后每次提交，会自动进行构建发布 Reference The world’s fastest framework for building websites | Hugo ox-hugo - Org to Hugo exporter GitHub - dillonzq/LoveIt: ❤️A clean, elegant but advanced blog theme for Hugo…","description":"","tags":["hugo"],"title":"利用 emacs + hugo 搭建个人博客","uri":"/posts/%E5%88%A9%E7%94%A8-emacs-+-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]
